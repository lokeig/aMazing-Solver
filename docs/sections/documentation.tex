\subsection{Mazes}

\subsubsection{Interface}

The core types that different parts of the program interface with are mazes, paths, maze solvers and maze generators. A maze stores its start and end positions, the width and height of the maze and a two-dimensional array of cells describing the maze where each cell can be either a wall or empty. A path is an array of actions where each action can either be checking wether a cell at a position is a wall or to move one step in a cardinal direction. A maze solver is a function that takes a maze as input and returns a path that solves that maze. A maze generator takes a width and a height as input and returns a randomly generated maze as output.

\subsubsection{Path Verification}

The verify\_path function takes a path and a maze as parameters and returns wether that path successfully moves from the start to the end of the maze without ever moving into a wall cell.

\subsubsection{Solver Wrapper}

To aid the creation of maze solvers, a solver\_wrapper function has been created that takes a function as input and returns a maze solver. The wrapper defines variables to keep track of the current position in the maze and the path it has taken to get there. The input function is then passed five arguments: the end position of the maze, a function to get the current position in the maze, a function to check wether a position lies within the maze, a function to check wether a cell at a position is a wall and a function to move one step in a cardinal direction. These functions also update the current position and path accordingly.

\subsection{Maze Solving Algorithms}

\subsubsection{A*}

A* \cite{a-star-alg} is implemented as a maze solver using the solver wrapper. It will always find the shortest path and always halt.

\subsubsection{Depth First Search}

DFS \cite{pkd} is implemented as a maze solver using the solver wrapper. It will not always find the shortest path but will always halt.

\subsubsection{Dijkstra's Algorithm}

Dijkstra's algorithm \cite{dijkstras-alg} is implemented as a maze solver using the solver wrapper. It will always find the shortest path and always halt.

\subsubsection{The Maze Routing algorithm}

The maze routing algorithm \cite{maze-routing-alg} is implemented as a maze solver using the solver wrapper. It will not always find the shortest path and may not halt when the maze is not solvable.

\subsubsection{aMazing Language Implementations}

In addition to typescript, each maze solving algorithm used is also implemented as strings executable by the aMazing Language in maze mode.

\subsection{Component Overview}
This component overview provides a detailed explanation of the components used for this React application.

\subsubsection{Board}
The \texttt{Board} component renders and updates the interactive grid where the various pathfinding algorithms are visualized.

\paragraph{Data Types} \

The \texttt{Board} consists of two types:
\begin{itemize}
    \item \texttt{Node}: Represents a single cell in the grid with properties about its row and column indices, and optional status as a start node, end node, or wall.
    \item \texttt{Grid}: Represents the entire grid as a 2D array of nodes, references to the start and end nodes, and the number of rows and columns.
\end{itemize}

\paragraph{Integration with GridContext} \

The component uses \texttt{useGrid}, a custom Hook that provides the current grid state, and a function \texttt{setGrid} to update the grid state and invoke a re-render.

\paragraph{Grid Initialization} \

When the \texttt{Board} component is mounted, a \texttt{useEffect} Hook retrieves dimensions using \texttt{boardRef} and calculates the number of rows and columns based on a 24-pixel cell size. A grid is created using \texttt{makeGrid} and the initial grid is updated with the new grid. The effect runs only when \texttt{setGrid} changes because it is in the dependency list. Since setGrid is a state updater function (which does not change between renders), this effect essentially runs once on mount.

\paragraph{Interacting with the Grid} \

The \texttt{Board} component enables user interactions through mouse event handlers:

\begin{itemize}
    \item \texttt{handleMouseDown}: Determines whether the clicked cell is a start node, end node, or regular cell, and assigns an action.
    \item \texttt{handleMouseEnter}: Moves the start or end node and modifies walls.
    \item \texttt{handleMouseUp}: Resets the references to null and updates the grid state.
\end{itemize}

\paragraph{Rendering} \

The grid is rendered as an HTML table. Each cell has an ID generated by \texttt{getNodeID}. The mouse event handlers are attached to support the interactive features.

The update logic decouples the immediate visual feedback from the underlying grid state for performance reasons. When the user interacts with the \texttt{Board}, the component directly manipulates the DOM by adding or removing CSS classes on the cells. When the user completes an interaction, \texttt{updateGrid} is called to update the grid state.

\paragraph{Helper Functions} \

\begin{itemize}
    \item \texttt{editWall}: Modifies the wall state of a specific cell. If the cell is not marked as a start or end node, it toggles the wall status based on whether the current action in \texttt{wallRef} is to add or remove a wall. This function adds or removes the corresponding CSS class to visually update the cell.
    \item \texttt{moveNode}: Allows repositioning of the start or end node. It first ensures that the target cell is not a wall and not occupied by the opposite node. The function then changes the CSS to reflect the node’s new position.
    \item \texttt{styles}: Uses the clsx library to dynamically compute and return a string of CSS classes for a given cell. This helps in applying different styles (e.g., for walls, start, and end nodes) based on the cell’s state.
\end{itemize}

\subsubsection{Context}

GridContext and EditorContext leverage React's Context API to create contexts that let components share information without explicitly passing props.

\paragraph{GridContext and EditorContext} \

The \texttt{Editor} and \texttt{Board} share information with the Header component. This establishes a single source of truth that the components can derive from.

The GridContext component defines a GridProvider that wraps the components that need to access the information from it. In App.tsx, the GridProvider wraps both the Header and the Board component, allowing them to share information.
The information shared is the grid and disabled state, and the functions that update them.

\begin{verbatim}
    const [grid, setGrid] = useState<Grid>(makeGrid(0, 0));
    const [disabled, setDisabled] = useState<boolean>(false);
\end{verbatim}

Similarly, the EditorContext defines an EditorProvider that shares information about the code in the editor, the logs, and functions that update them.

To access the information needed, we define useGrid and useEditor inside Board and Editor respectively.

\begin{verbatim}
export function useGrid(): GridState {
    const context: GridState | null = useContext(GridContext);
    if (!context) {
        throw new Error(
            "useGrid must be used within a GridProvider"
        );
    }
    return context;
}
\end{verbatim}

\subsubsection{Header}

The Header component interfaces with the Board and Editor components. It uses information from context to update and display data.

\paragraph{Helper Functions} \

\begin{itemize}
    \item \texttt{clearSearch}: Clears previous searches and paths if there are any.
    \item \texttt{clearBoard}: Resets the entire Board and updates the grid state if there are walls, visited nodes, or paths.
    \item \texttt{generateMaze}: Resets the board and uses recursive division to generate a maze.
    \item \texttt{run}: Starts the visualization. If the code editor is displayed, it will run the code in the editor.
\end{itemize}

\subsubsection{Editor}

The Editor component renders a simple code editor that allow users to implement their own algorithms in aMazing Language.

\paragraph{Interacting with the Editor} \

The Editor consists of two Textarea components that are defined in Headless UI (Tailwind). One Textarea is used by the user to write code, and the other displays errors that would otherwise show on the console.

A helper function, \texttt{handleKeyDown}, prevents the default behavior of the tab allows the user to indent in the code editor. It uses a KeyboardEvent type defined in React to detect when the tab key is used.

\subsection{aMazing Language Interpreter}

\subsubsection{Tokenizer}

The first step of interpreting a string is to convert it to an array of tokens. A token consists of its type, the text it represents, the line number it started on and the column number it started on.

The input string is read one character at a time and that character is added to a string containing the current token. When whitespace is encountered or the current token string would become invalid, the current token string is matched against keyword, symbols, integer literal rules and variable naming rules. It it matches any of them, a new token of that type is pushed to the resulting array and the current token string is reset to begin accumulating the next token.

\subsubsection{Parser}

Second is to convert the token array of tokens into intermediate representation. The intermediate representation is a tree-like structure where each node contains the type of expression or statement it represents as well as what other values and nodes it consists of.

The input array is treated as a stack from which tokens are consumed as subexpressions are parsed. The main parse function will look at the next token and depending on what it is, it will call different helper functions capable of parsing that specific type of statement. Those functions will in turn call different helpers to parse the expressions they consist of which will call helpers to parse their subexpressions. Once all subexpressions are parsed they can be combined into the full expression node and returned to be combined into a full statement node and so on.

\subsubsection{Evaluator}

The evaluator will use the tokenizer and parser to get the inputs intermediate representation. It uses environment frame to store a table for looking up the values associated with variable names as well as what frame to fall back on if a name could not be found.

The predefined values are defined in a new environment frame before starting the evaluation of the intermediate representation in a new frame with that as fallback. Similarly to the parser, when evaluating statements, helper functions are called to parse the expressions that make them up which in turn call helper functions that evaluate their subexpressions and so on. Eventually, a function is returned that will evaluate the main function of the input using this same method.

\subsubsection{Maze Solving Evaluator}

To evaluate in maze mode, the solver wrapper is used. The regular evaluator is used but the functions passed by the solver wrapper are exposed to the program as additional predefined values. Additionally, the main function is called with the end position's coordinates as arguments. A tuple of a maze solver and an array of strings is returned. The array of strings represents the programs standard output and will be filled with the strings printed during execution after the maze solver is called.
